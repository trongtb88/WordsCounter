package main

import (
	"fmt"
	"log"
	"sort"
	"strings"
	"sync"
	"time"
)
//Using GoLang, Kindly produce a simple function/method that accepts a body of text as input  (for example a page from a book) and returns the top ten most-used words along with how many times they occur in the text.
func main() {

	// Will print time of execution after main func finish.
	defer timeTrack(time.Now(), "factorial")

	text := "Queries are seldom simple one-clause match queries. " +
		"We frequently need to search for the same or different query strings in one or more fields, which means that we need to be able to combine multiple query clauses and their relevance scores in a way that makes sense.\nPerhaps we’re looking for a book called War and Peace by an author called Leo Tol‐ stoy. Perhaps we’re searching the Elasticsearch documentation for “minimum should match,” which might be in the title or the body of a page. Or perhaps we’re searching for users with first name John and last name Smith.\nIn this chapter, we present the available tools for constructing multiclause searches and how to figure out which solution you should apply to your particular use case.\nMultiple Query Strings\nThe simplest multifield query to deal with is the one where we can map search terms to specific fields. If we know that War and Peace is the title, and Leo Tolstoy is the author, it is easy to write each of these conditions as a match clause and to combine them with a bool query:\nGET /_search {\n      \"query\": {\n        \"bool\": {\n          \"should\": [\n            { \"match\": { \"title\":  \"War and Peace\" }},\n            { \"match\": { \"author\": \"Leo Tolstoy\"   }}\n] }\n} }\nCHAPTER 14 Multifield Search\n  217\nThe bool query takes a more-matches-is-better approach, so the score from each match clause will be added together to provide the final _score for each document. Documents that match both clauses will score higher than documents that match just one clause.\nOf course, you’re not restricted to using just match clauses: the bool query can wrap any other query type, including other bool queries. We could add a clause to specify that we prefer to see versions of the book that have been translated by specific transla‐ tors:\nGET /_search {\n      \"query\": {\n        \"bool\": {\n          \"should\": [\n            { \"match\": { \"title\":  \"War and Peace\" }},\n            { \"match\": { \"author\": \"Leo Tolstoy\"   }},\n            { \"bool\":  {\n              \"should\": [\n                { \"match\": { \"translator\": \"Constance Garnett\" }},\n                { \"match\": { \"translator\": \"Louise Maude\"      }}\n] }}\n] }\n} }\nWhy did we put the translator clauses inside a separate bool query? All four match queries are should clauses, so why didn’t we just put the translator clauses at the same level as the title and author clauses?\nThe answer lies in how the score is calculated. The bool query runs each match query, adds their scores together, then multiplies by the number of matching clauses, and divides by the total number of clauses. Each clause at the same level has the same weight. In the preceding query, the bool query containing the translator clauses counts for one-third of the total score. If we had put the translator clauses at the same level as title and author, they would have reduced the contribution of the title and author clauses to one-quarter each.\nPrioritizing Clauses\nIt is likely that an even one-third split between clauses is not what we need for the preceding query. Probably we’re more interested in the title and author clauses then we are in the translator clauses. We need to tune the query to make the title and author clauses relatively more important.\n 218 | Chapter 14: Multifield Search\n\nThe simplest weapon in our tuning arsenal is the boost parameter. To increase the weight of the title and author fields, give them a boost value higher than 1:\nGET /_search {\n      \"query\": {\n        \"bool\": {\n          \"should\": [\n            { \"match\": {\n                \"title\":  {\n                  \"query\": \"War and Peace\",\n                  \"boost\": 2\n            }}},\n            { \"match\": {\n                \"author\":  {\n                  \"query\": \"Leo Tolstoy\",\n                  \"boost\": 2\n            }}},\n            { \"bool\":  {\n                \"should\": [\n                  { \"match\": { \"translator\": \"Constance Garnett\" }},\n                  { \"match\": { \"translator\": \"Louise Maude\"      }}\n] }}\n] }\n} }\nThe title and author clauses have a boost value of 2. The nested bool clause has the default boost of 1.\nThe “best” value for the boost parameter is most easily determined by trial and error: set a boost value, run test queries, repeat. A reasonable range for boost lies between 1 and 10, maybe 15. Boosts higher than that have little more impact because scores are normalized.\nSingle Query String\nThe bool query is the mainstay of multiclause queries. It works well for many cases, especially when you are able to map different query strings to individual fields.\nThe problem is that, these days, users expect to be able to type all of their search terms into a single field, and expect that the application will figure out how to give them the right results. It is ironic that the multifield search form is known as Advanced Search—it may appear advanced to the user, but it is much simpler to implement.\n Single Query String | 219\n\nThere is no simple one-size-fits-all approach to multiword, multifield queries. To get the best results, you have to know your data and know how to use the appropriate tools.\nKnow Your Data\nWhen your only user input is a single query string, you will encounter three scenarios frequently:\nBest fields\nWhen searching for words that represent a concept, such as “brown fox,” the words mean more together than they do individually. Fields like the title and body, while related, can be considered to be in competition with each other. Documents should have as many words as possible in the same field, and the score should come from the best-matching field.\nMost fields\nA common technique for fine-tuning relevance is to index the same data into multiple fields, each with its own analysis chain.\nThe main field may contain words in their stemmed form, synonyms, and words stripped of their diacritics, or accents. It is used to match as many documents as possible.\nThe same text could then be indexed in other fields to provide more-precise matching. One field may contain the unstemmed version, another the original word with accents, and a third might use shingles to provide information about word proximity.\nThese other fields act as signals to increase the relevance score of each matching document. The more fields that match, the better.\nCross fields\nFor some entities, the identifying information is spread across multiple fields, each of which contains just a part of the whole:\n• Person:first_nameandlast_name\n• Book: title, author, and description\n• Address: street, city, country, and postcode\nIn this case, we want to find as many words as possible in any of the listed fields. We need to search across multiple fields as if they were one big field.\nAll of these are multiword, multifield queries, but each requires a different strategy. We will examine each strategy in turn in the rest of this chapter.\n 220 | Chapter 14: Multifield Search\n\nBest Fields\nImagine that we have a website that allows users to search blog posts, such as these two documents:\nPUT /my_index/my_type/1 {\n        \"title\": \"Quick brown rabbits\",\n\"body\": \"Brown rabbits are commonly seen.\" }\nPUT /my_index/my_type/2 {\n        \"title\": \"Keeping pets healthy\",\n\"body\": \"My quick brown fox eats rabbits on a regular basis.\" }\nThe user types in the words “Brown fox” and clicks Search. We don’t know ahead of time if the user’s search terms will be found in the title or the body field of the post, but it is likely that the user is searching for related words. To our eyes, document 2 appears to be the better match, as it contains both words that we are looking for.\nNow we run the following bool query: {\n        \"query\": {\n            \"bool\": {\n                \"should\": [\n                    { \"match\": { \"title\": \"Brown fox\" }},\n                    { \"match\": { \"body\":  \"Brown fox\" }}\n] }\n} }\nAnd we find that this query gives document 1 the higher score:\n{\n\"hits\": [\n{\n\"_id\": \"1\", \"_score\": 0.14809652, \"_source\": {\n               \"title\": \"Quick brown rabbits\",\n\"body\": \"Brown rabbits are commonly seen.\" }\n}, {\n\"_id\": \"2\", \"_score\": 0.09256032, \"_source\": {\n   \"title\": \"Keeping pets healthy\",\n Best Fields\n| 221\n\n\"body\": \"My quick brown fox eats rabbits on a regular basis.\" }\n} ]\n}\nTo understand why, think about how the bool query calculates its score:\n1. It runs both of the queries in the should clause.\n2. It adds their scores together.\n3. It multiplies the total by the number of matching clauses.\n4. It divides the result by the total number of clauses (two).\nDocument 1 contains the word brown in both fields, so both match clauses are suc‐ cessful and have a score. Document 2 contains both brown and fox in the body field but neither word in the title field. The high score from the body query is added to the zero score from the title query, and multiplied by one-half, resulting in a lower overall score than for document 1.\nIn this example, the title and body fields are competing with each other. We want to find the single best-matching field.\nWhat if, instead of combining the scores from each field, we used the score from the best-matching field as the overall score for the query? This would give preference to a single field that contains both of the words we are looking for, rather than the same word repeated in different fields.\ndis_max Query\nInstead of the bool query, we can use the dis_max or Disjunction Max Query. Dis‐ junction means or (while conjunction means and) so the Disjunction Max Query simply means return documents that match any of these queries, and return the score of the best matching query:\n{\n\"query\": {\n\"dis_max\": { \"queries\": [\n                    { \"match\": { \"title\": \"Brown fox\" }},\n                    { \"match\": { \"body\":  \"Brown fox\" }}\n                ]\n} }\n}\nThis produces the results that we want:\n 222 | Chapter 14: Multifield Search\n\n{\n\"hits\": [\n{\n\"_id\": \"2\", \"_score\": 0.21509302, \"_source\": {\n               \"title\": \"Keeping pets healthy\",\n\"body\": \"My quick brown fox eats rabbits on a regular basis.\" }\n}, {\n} ]\n}\nTuning Best Fields Queries\nWhat would happen if the user had searched instead for “quick pets”? Both docu‐ ments contain the word quick, but only document 2 contains the word pets. Neither document contains both words in the same field.\nA simple dis_max query like the following would choose the single best matching field, and ignore the other:\n{\n\"query\": {\n\"dis_max\": { \"queries\": [\n                    { \"match\": { \"title\": \"Quick pets\" }},\n                    { \"match\": { \"body\":  \"Quick pets\" }}\n                ]\n} }\n} {\n\"hits\": [ {\n\"_id\": \"1\", \"_score\": 0.12713557, \"_source\": {\n               \"title\": \"Quick brown rabbits\",\n\"body\": \"Brown rabbits are commonly seen.\" }\n}, {\n\"_id\": \"1\", \"_score\": 0.12713557, \"_source\": {\n   \"title\": \"Quick brown rabbits\",\n\"body\": \"Brown rabbits are commonly seen.\" }\n Tuning Best Fields Queries\n| 223\n\n\"_id\": \"2\", \"_score\": 0.12713557, \"_source\": {\n               \"title\": \"Keeping pets healthy\",\n\"body\": \"My quick brown fox eats rabbits on a regular basis.\" }\n} ]\n}\nNote that the scores are exactly the same.\nWe would probably expect documents that match on both the title field and the body field to rank higher than documents that match on just one field, but this isn’t the case. Remember: the dis_max query simply uses the _score from the single best- matching clause.\ntie_breaker\nIt is possible, however, to also take the _score from the other matching clauses into account, by specifying the tie_breaker parameter:\n{\n\"query\": {\n\"dis_max\": { \"queries\": [\n                    { \"match\": { \"title\": \"Quick pets\" }},\n                    { \"match\": { \"body\":  \"Quick pets\" }}\n                ],\n\"tie_breaker\": 0.3 }\n} }\nThis gives us the following results:\n{\n\"hits\": [\n{\n\"_id\": \"2\",\n\"_score\": 0.14757764, \"_source\": {\n               \"title\": \"Keeping pets healthy\",\n\"body\": \"My quick brown fox eats rabbits on a regular basis.\" }\n}, {\n\"_id\": \"1\",\n\"_score\": 0.124275915, \"_source\": {\n   \"title\": \"Quick brown rabbits\",\n 224 |\nChapter 14: Multifield Search\n\n\"body\": \"Brown rabbits are commonly seen.\" }\n} ]\n}\nDocument 2 now has a small lead over document 1.\nThe tie_breaker parameter makes the dis_max query behave more like a halfway\nhouse between dis_max and bool. It changes the score calculation as follows:\n1. Take the _score of the best-matching clause.\n2. Multiply the score of each of the other matching clauses by the tie_breaker.\n3. Add them all together and normalize.\nWith the tie_breaker, all matching clauses count, but the best-matching clause counts most.\nThe tie_breaker can be a floating-point value between 0 and 1, where 0 uses just the best-matching clause and 1 counts all match‐ ing clauses equally. The exact value can be tuned based on your data and queries, but a reasonable value should be close to zero, (for example, 0.1 - 0.4), in order not to overwhelm the best- matching nature of dis_max.\nmulti_match Query\nThe multi_match query provides a convenient shorthand way of running the same query against multiple fields.\nThere are several types of multi_match query, three of which just happen to coincide with the three scenarios that we listed in “Know Your Data” on page 220: best_fields, most_fields, and cross_fields.\nBy default, this query runs as type best_fields, which means that it generates a match query for each field and wraps them in a dis_max query. This dis_max query We frequently need to search for the same or different query strings in one or more fields, which means that we need to be able to combine multiple query clauses and their relevance scores in a way that makes sense.\nPerhaps we’re looking for a book called War and Peace by an author called Leo Tol‐ stoy. Perhaps we’re searching the Elasticsearch documentation for “minimum should match,” which might be in the title or the body of a page. Or perhaps we’re searching for users with first name John and last name Smith.\nIn this chapter, we present the available tools for constructing multiclause searches and how to figure out which solution you should apply to your particular use case.\nMultiple Query Strings\nThe simplest multifield query to deal with is the one where we can map search terms to specific fields. If we know that War and Peace is the title, and Leo Tolstoy is the author, it is easy to write each of these conditions as a match clause and to combine them with a bool query:\nGET /_search {\n      \"query\": {\n        \"bool\": {\n          \"should\": [\n            { \"match\": { \"title\":  \"War and Peace\" }},\n            { \"match\": { \"author\": \"Leo Tolstoy\"   }}\n] }\n} }\nCHAPTER 14 Multifield Search\n  217\nThe bool query takes a more-matches-is-better approach, so the score from each match clause will be added together to provide the final _score for each document. Documents that match both clauses will score higher than documents that match just one clause.\nOf course, you’re not restricted to using just match clauses: the bool query can wrap any other query type, including other bool queries. We could add a clause to specify that we prefer to see versions of the book that have been translated by specific transla‐ tors:\nGET /_search {\n      \"query\": {\n        \"bool\": {\n          \"should\": [\n            { \"match\": { \"title\":  \"War and Peace\" }},\n            { \"match\": { \"author\": \"Leo Tolstoy\"   }},\n            { \"bool\":  {\n              \"should\": [\n                { \"match\": { \"translator\": \"Constance Garnett\" }},\n                { \"match\": { \"translator\": \"Louise Maude\"      }}\n] }}\n] }\n} }\nWhy did we put the translator clauses inside a separate bool query? All four match queries are should clauses, so why didn’t we just put the translator clauses at the same level as the title and author clauses?\nThe answer lies in how the score is calculated. The bool query runs each match query, adds their scores together, then multiplies by the number of matching clauses, and divides by the total number of clauses. Each clause at the same level has the same weight. In the preceding query, the bool query containing the translator clauses counts for one-third of the total score. If we had put the translator clauses at the same level as title and author, they would have reduced the contribution of the title and author clauses to one-quarter each.\nPrioritizing Clauses\nIt is likely that an even one-third split between clauses is not what we need for the preceding query. Probably we’re more interested in the title and author clauses then we are in the translator clauses. We need to tune the query to make the title and author clauses relatively more important.\n 218 | Chapter 14: Multifield Search\n\nThe simplest weapon in our tuning arsenal is the boost parameter. To increase the weight of the title and author fields, give them a boost value higher than 1:\nGET /_search {\n      \"query\": {\n        \"bool\": {\n          \"should\": [\n            { \"match\": {\n                \"title\":  {\n                  \"query\": \"War and Peace\",\n                  \"boost\": 2\n            }}},\n            { \"match\": {\n                \"author\":  {\n                  \"query\": \"Leo Tolstoy\",\n                  \"boost\": 2\n            }}},\n            { \"bool\":  {\n                \"should\": [\n                  { \"match\": { \"translator\": \"Constance Garnett\" }},\n                  { \"match\": { \"translator\": \"Louise Maude\"      }}\n] }}\n] }\n} }\nThe title and author clauses have a boost value of 2. The nested bool clause has the default boost of 1.\nThe “best” value for the boost parameter is most easily determined by trial and error: set a boost value, run test queries, repeat. A reasonable range for boost lies between 1 and 10, maybe 15. Boosts higher than that have little more impact because scores are normalized.\nSingle Query String\nThe bool query is the mainstay of multiclause queries. It works well for many cases, especially when you are able to map different query strings to individual fields.\nThe problem is that, these days, users expect to be able to type all of their search terms into a single field, and expect that the application will figure out how to give them the right results. It is ironic that the multifield search form is known as Advanced Search—it may appear advanced to the user, but it is much simpler to implement.\n Single Query String | 219\n\nThere is no simple one-size-fits-all approach to multiword, multifield queries. To get the best results, you have to know your data and know how to use the appropriate tools.\nKnow Your Data\nWhen your only user input is a single query string, you will encounter three scenarios frequently:\nBest fields\nWhen searching for words that represent a concept, such as “brown fox,” the words mean more together than they do individually. Fields like the title and body, while related, can be considered to be in competition with each other. Documents should have as many words as possible in the same field, and the score should come from the best-matching field.\nMost fields\nA common technique for fine-tuning relevance is to index the same data into multiple fields, each with its own analysis chain.\nThe main field may contain words in their stemmed form, synonyms, and words stripped of their diacritics, or accents. It is used to match as many documents as possible.\nThe same text could then be indexed in other fields to provide more-precise matching. One field may contain the unstemmed version, another the original word with accents, and a third might use shingles to provide information about word proximity.\nThese other fields act as signals to increase the relevance score of each matching document. The more fields that match, the better.\nCross fields\nFor some entities, the identifying information is spread across multiple fields, each of which contains just a part of the whole:\n• Person:first_nameandlast_name\n• Book: title, author, and description\n• Address: street, city, country, and postcode\nIn this case, we want to find as many words as possible in any of the listed fields. We need to search across multiple fields as if they were one big field.\nAll of these are multiword, multifield queries, but each requires a different strategy. We will examine each strategy in turn in the rest of this chapter.\n 220 | Chapter 14: Multifield Search\n\nBest Fields\nImagine that we have a website that allows users to search blog posts, such as these two documents:\nPUT /my_index/my_type/1 {\n        \"title\": \"Quick brown rabbits\",\n\"body\": \"Brown rabbits are commonly seen.\" }\nPUT /my_index/my_type/2 {\n        \"title\": \"Keeping pets healthy\",\n\"body\": \"My quick brown fox eats rabbits on a regular basis.\" }\nThe user types in the words “Brown fox” and clicks Search. We don’t know ahead of time if the user’s search terms will be found in the title or the body field of the post, but it is likely that the user is searching for related words. To our eyes, document 2 appears to be the better match, as it contains both words that we are looking for.\nNow we run the following bool query: {\n        \"query\": {\n            \"bool\": {\n                \"should\": [\n                    { \"match\": { \"title\": \"Brown fox\" }},\n                    { \"match\": { \"body\":  \"Brown fox\" }}\n] }\n} }\nAnd we find that this query gives document 1 the higher score:\n{\n\"hits\": [\n{\n\"_id\": \"1\", \"_score\": 0.14809652, \"_source\": {\n               \"title\": \"Quick brown rabbits\",\n\"body\": \"Brown rabbits are commonly seen.\" }\n}, {\n\"_id\": \"2\", \"_score\": 0.09256032, \"_source\": {\n   \"title\": \"Keeping pets healthy\",\n Best Fields\n| 221\n\n\"body\": \"My quick brown fox eats rabbits on a regular basis.\" }\n} ]\n}\nTo understand why, think about how the bool query calculates its score:\n1. It runs both of the queries in the should clause.\n2. It adds their scores together.\n3. It multiplies the total by the number of matching clauses.\n4. It divides the result by the total number of clauses (two).\nDocument 1 contains the word brown in both fields, so both match clauses are suc‐ cessful and have a score. Document 2 contains both brown and fox in the body field but neither word in the title field. The high score from the body query is added to the zero score from the title query, and multiplied by one-half, resulting in a lower overall score than for document 1.\nIn this example, the title and body fields are competing with each other. We want to find the single best-matching field.\nWhat if, instead of combining the scores from each field, we used the score from the best-matching field as the overall score for the query? This would give preference to a single field that contains both of the words we are looking for, rather than the same word repeated in different fields.\ndis_max Query\nInstead of the bool query, we can use the dis_max or Disjunction Max Query. Dis‐ junction means or (while conjunction means and) so the Disjunction Max Query simply means return documents that match any of these queries, and return the score of the best matching query:\n{\n\"query\": {\n\"dis_max\": { \"queries\": [\n                    { \"match\": { \"title\": \"Brown fox\" }},\n                    { \"match\": { \"body\":  \"Brown fox\" }}\n                ]\n} }\n}\nThis produces the results that we want:\n 222 | Chapter 14: Multifield Search\n\n{\n\"hits\": [\n{\n\"_id\": \"2\", \"_score\": 0.21509302, \"_source\": {\n               \"title\": \"Keeping pets healthy\",\n\"body\": \"My quick brown fox eats rabbits on a regular basis.\" }\n}, {\n} ]\n}\nTuning Best Fields Queries\nWhat would happen if the user had searched instead for “quick pets”? Both docu‐ ments contain the word quick, but only document 2 contains the word pets. Neither document contains both words in the same field.\nA simple dis_max query like the following would choose the single best matching field, and ignore the other:\n{\n\"query\": {\n\"dis_max\": { \"queries\": [\n                    { \"match\": { \"title\": \"Quick pets\" }},\n                    { \"match\": { \"body\":  \"Quick pets\" }}\n                ]\n} }\n} {\n\"hits\": [ {\n\"_id\": \"1\", \"_score\": 0.12713557, \"_source\": {\n               \"title\": \"Quick brown rabbits\",\n\"body\": \"Brown rabbits are commonly seen.\" }\n}, {\n\"_id\": \"1\", \"_score\": 0.12713557, \"_source\": {\n   \"title\": \"Quick brown rabbits\",\n\"body\": \"Brown rabbits are commonly seen.\" }\n Tuning Best Fields Queries\n| 223\n\n\"_id\": \"2\", \"_score\": 0.12713557, \"_source\": {\n               \"title\": \"Keeping pets healthy\",\n\"body\": \"My quick brown fox eats rabbits on a regular basis.\" }\n} ]\n}\nNote that the scores are exactly the same.\nWe would probably expect documents that match on both the title field and the body field to rank higher than documents that match on just one field, but this isn’t the case. Remember: the dis_max query simply uses the _score from the single best- matching clause.\ntie_breaker\nIt is possible, however, to also take the _score from the other matching clauses into account, by specifying the tie_breaker parameter:\n{\n\"query\": {\n\"dis_max\": { \"queries\": [\n                    { \"match\": { \"title\": \"Quick pets\" }},\n                    { \"match\": { \"body\":  \"Quick pets\" }}\n                ],\n\"tie_breaker\": 0.3 }\n} }\nThis gives us the following results:\n{\n\"hits\": [\n{\n\"_id\": \"2\",\n\"_score\": 0.14757764, \"_source\": {\n               \"title\": \"Keeping pets healthy\",\n\"body\": \"My quick brown fox eats rabbits on a regular basis.\" }\n}, {\n\"_id\": \"1\",\n\"_score\": 0.124275915, \"_source\": {\n   \"title\": \"Quick brown rabbits\",\n 224 |\nChapter 14: Multifield Search\n\n\"body\": \"Brown rabbits are commonly seen.\" }\n} ]\n}\nDocument 2 now has a small lead over document 1.\nThe tie_breaker parameter makes the dis_max query behave more like a halfway\nhouse between dis_max and bool. It changes the score calculation as follows:\n1. Take the _score of the best-matching clause.\n2. Multiply the score of each of the other matching clauses by the tie_breaker.\n3. Add them all together and normalize.\nWith the tie_breaker, all matching clauses count, but the best-matching clause counts most.\nThe tie_breaker can be a floating-point value between 0 and 1, where 0 uses just the best-matching clause and 1 counts all match‐ ing clauses equally. The exact value can be tuned based on your data and queries, but a reasonable value should be close to zero, (for example, 0.1 - 0.4), in order not to overwhelm the best- matching nature of dis_max.\nmulti_match Query\nThe multi_match query provides a convenient shorthand way of running the same query against multiple fields.\nThere are several types of multi_match query, three of which just happen to coincide with the three scenarios that we listed in “Know Your Data” on page 220: best_fields, most_fields, and cross_fields.\nBy default, this query runs as type best_fields, which means that it generates a match query for each field and wraps them in a dis_max query. This dis_max query"
	
	// We will make string a bit of clear, remove some special characters and give a list of clean words
	fields := strings.FieldsFunc(text, func(r rune) bool {
		return !('a' <= r && r <= 'z' || 'A' <= r && r <= 'Z')
	})

	// Spilit cleaned strings into smaller chunks to using concurrency counting apper words
	a := chunks(fields, 500)

	wg := sync.WaitGroup{}
	wordsCountChannel := make(chan map[string]int64, len(a))
	// Each chunked will be count by new goroutine for best performance.
	for _, chunkedWords  := range a {
		wg.Add(1)
		go func(g *sync.WaitGroup, words []string) {
			defer g.Done()
			wordsCount := make(map[string]int64)
			for _, word := range words {
				wordsCount[strings.ToLower(word)]++
			}
			wordsCountChannel <- wordsCount

		}(&wg, chunkedWords)
	}

	// Wait until all goroutines finish
	wg.Wait()
	close(wordsCountChannel)

	// We will bulid list of words with their count.
	wordCounts := make([]WordCount, 0)
	m := make(map[string]int64)

	// Get results from counter channel
	for wordsMap := range wordsCountChannel{
		for key, val := range wordsMap {
			m[key] += val
		}
	}

	// Build list of words
	for key, val := range m {
		wordCounts = append(wordCounts, WordCount{word: key, count: val})
	}


	// Sort by number they occur
	sort.Slice(wordCounts, func(i, j int) bool {
		return wordCounts[i].count > wordCounts[j].count
	})

	// Show the top-ten most frequent words
	for i := 0; i < len(wordCounts) && i < 10; i++ {
		fmt.Println(wordCounts[i].word, ":", wordCounts[i].count)
	}
}

type WordCount struct {
	word  string
	count int64
}

func timeTrack(start time.Time, name string) {
	elapsed := time.Since(start)
	log.Printf("%s took %s", name, elapsed)
}

func chunks(xs []string, chunkSize int) [][]string {
	if len(xs) == 0 {
		return nil
	}
	divided := make([][]string, (len(xs)+chunkSize-1)/chunkSize)
	prev := 0
	i := 0
	till := len(xs) - chunkSize
	for prev < till {
		next := prev + chunkSize
		divided[i] = xs[prev:next]
		prev = next
		i++
	}
	divided[i] = xs[prev:]
	return divided
}